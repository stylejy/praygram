{
  "rules": [
    {
      "type": "prd",
      "content": "# 제품 요구사항 문서 (PRD)\n\n## 1. 개요\n기도모임을 위한 PWA 웹·앱 ‘Praygram’은 사용자가 기도제목을 올리고, 같은 그룹 내 구성원이 확인·응답(“기도했습니다”)할 수 있는 온라인 기도 커뮤니티입니다. 카카오톡 등 일반 메신저 대비 기도에만 집중할 수 있도록 설계되어, 기도제목의 누락·분산을 방지하고 즉각적 영적 피드백을 제공합니다.\n\n## 2. 문제 정의\n1. 카카오톡 등 메신저는 다양한 메시지로 인해 기도제목이 뒤로 밀려 검색·추적이 어려움  \n2. 세속적·불필요한 정보 노출로 기도 집중도 저하  \n3. 타인이 기도해줬다는 확인(리액션) 경로 부재  \n4. 그룹별 비공개·분리된 기도 공간이 없음\n\n## 3. 목표 및 목적\n- 1차 목표: 전용 플랫폼에서 기도제목 공유·기록·피드백 기능 제공\n- 2차 목표: 모바일 친화 UI, 카카오 로그인, 그룹 기반 권한 관리\n- 성공 지표\n  - 월간 활성 사용자(MAU) 1,000명 이상\n  - 기도제목 당 평균 피드백 2회 이상\n  - 재방문률 60% 이상\n  - 페이지 평균 로딩 2초 이하(P95)\n\n## 4. 대상 사용자\n### 주요 사용자\n- 20~60대 기도생활이 활발한 기독교인  \n- 주 1회 이상 모임·기도제목 공유 경험자  \n- 모바일 사용 비중이 높은 신앙인\n### 이해관계자\n- 교회·선교단체 리더  \n- 기도사역 담당자  \n- IT 봉사자\n\n## 5. 사용자 스토리\n- “신앙인으로서, 특정 기도제목을 빠르게 등록해 모임원에게 알려 집중적으로 기도받고 싶다.”\n- “모임 구성원으로서, 다른 사람이 올린 기도제목에 ‘기도했습니다’로 즉시 반응해 격려하고 싶다.”\n- “리더로서, 내 그룹 기도제목만 분리해 보고 관리하고 싶다.”\n- “사용자로서, 카카오 계정으로 1초 내 로그인해 번거로움을 줄이고 싶다.”\n- “모바일에서, 네트워크가 불안정해도 최근 기도제목을 오프라인으로 보고 싶다.”\n\n## 6. 기능 요구사항\n### 핵심 기능\n1. 기도제목 작성·편집·삭제  \n   - 제목(최대 100자), 내용(500자), 요청자 자동 태그  \n   - 수락 기준: 저장 후 리스트 즉시 갱신\n2. 그룹 생성·초대·권한  \n   - 리더만 초대 코드·링크 발급  \n   - 멤버 역할: 작성·리액션 가능\n3. 리액션(기도 확인)  \n   - ‘🙏 기도했습니다’ 1회 누적, 취소 가능  \n   - 실시간 카운트 표시\n4. 카카오톡 OAuth 로그인  \n   - 최초 로그인 시 Supabase Auth에 사용자 레코드 생성\n5. 모바일 반응형 UI  \n   - 360px~1920px 뷰포트 최적화\n### 지원 기능\n- PWA 설치, 오프라인 캐싱(Service Worker)  \n- 웹푸시(Prayer push): 즐겨찾기한 기도제목 업데이트 알림  \n- 검색·필터(작성자, 날짜, 키워드)  \n- 다크모드, 접근성(ARIA)  \n- 관리자 대시보드(사용자·그룹 통계)\n\n## 7. 비기능 요구사항\n- 성능: 목록 로드 1,000건 내 3초 이하  \n- 보안: TLS 1.2 이상, Supabase Row-Level Security, JWT  \n- 사용성: NPS 40 이상, 아이콘+문구 쉬운 이해  \n- 확장성: Postgres 파티셔닝으로 월 10만 건 처리  \n- 호환성: 최신 Chrome, Safari, Edge, Android WebView, iOS PWA\n\n## 8. 기술 고려사항\n- 아키텍처: Next.js(SSR+ISR) + Supabase(Postgres·Auth·Storage)  \n- 인증: Kakao OAuth → Supabase JWT  \n- 데이터 모델  \n  - tables: users, groups, group_members, prayers, reactions  \n- PWA: Workbox, `manifest.json`, offline cache  \n- 제3자 연동: Kakao SDK, Supabase JS, VAPID Push\n\n## 9. 성공 측정지표\n- 제품 채택: 가입자수, 그룹 생성수  \n- 사용자 참여: 평균 리액션 수, 활성 그룹 비율  \n- 비즈니스: 서버 비용 대비 사용자당 가치(후원·기부)  \n- 기술: 오류율 <1%, Lighthouse PWA 점수 90+\n\n## 10. 일정 및 마일스톤\n| 단계 | 기간 | 주요 산출물 |\n|---|---|---|\n| 1. 기획 완료 | W0 | PRD 승인 |\n| 2. MVP 개발 | W1~W6 | 핵심 기능 1~5 배포 |\n| 3. 베타 테스트 | W7~W8 | 피드백 수집, 버그 픽스 |\n| 4. 정식 출시 | W9 | 스토어·웹 공개, 마케팅 |\n| 5. 고도화 | W10~W14 | 푸시, 검색, 대시보드 |\n\n## 11. 위험 및 대응\n- 카카오 정책 변경 → 구글·애플 로그인 옵션 준비  \n- 낮은 사용자 유입 → 교회 연계 홍보, SNS 바이럴  \n- 데이터 유출 위험 → 주기적 PenTest, 로깅·모니터링  \n- 스케일 급증 → Supabase 리소스 오토스케일, CDN 캐시\n\n## 12. 향후 계획\n- iOS·Android 네이티브 쉘(React Native)  \n- 다국어(영·스·일) 지원  \n- 기도타이머, 실시간 음성·영상 기도방  \n- AI 요약·분류로 기도제목 카테고리 자동 추천",
      "writedAt": "2025-07-19T02:51:46.332Z"
    },
    {
      "type": "architecture",
      "content": "# Technical Requirements Document (TRD)\n\n## 1. Executive Technical Summary\n- **프로젝트 개요**  \n  ‘Praygram’은 Next.js 기반 PWA 웹·앱으로, 사용자가 기도제목을 등록·편집·삭제하고 그룹 내에서 “기도했습니다” 리액션을 실시간으로 주고받는 온라인 기도 커뮤니티입니다. Supabase(Postgres·Auth·Storage)를 백엔드로 활용하며, Vercel에 배포하여 SSR·ISR을 통한 빠른 초기 로드와 안정적인 호스팅 환경을 제공합니다.\n- **핵심 기술 스택**  \n  Next.js, TypeScript, Supabase, Vercel, Workbox(Service Worker)\n- **주요 기술 목표**  \n  • 페이지 로드 P95 < 2초  \n  • 월 10만 건 이상 기도제목 처리 가능 확장성  \n  • TLS 1.2 이상 및 Supabase RLS·JWT 기반 보안  \n  • 오프라인에서도 최근 기도제목 조회·등록 지원  \n- **핵심 가정 사항**  \n  • 사용자 규모: 초기 MAU 1,000명, 장기 10만명 이상  \n  • 네트워크 불안정 환경에서도 PWA 오프라인 캐싱으로 기본 기능 제공  \n  • Kakao OAuth 안정적 제공 및 Supabase 연동\n\n## 2. Tech Stack\n\n| Category          | Technology / Library             | Reasoning (선택 이유)                                                     |\n| ----------------- | -------------------------------- | ------------------------------------------------------------------------- |\n| 프레임워크        | Next.js (v13.x)                  | SSR·ISR 지원, PWA 친화적 라우팅 및 빌트인 이미지 최적화                    |\n| 언어              | TypeScript (v4.x)                | 정적 타입 안정성 확보, 코드 완성도 및 유지보수성 향상                      |\n| 인증/인가         | Supabase Auth + Kakao OAuth      | 통합된 JWT 발급·RLS 지원, 카카오 간편 로그인 연동                          |\n| API 설계          | Next.js API Routes (RESTful)     | 단일 프레임워크 내 RESTful 엔드포인트 구현 용이                             |\n| 데이터베이스      | Supabase PostgreSQL              | 완전관리형 Postgres, RLS·Realtime·Storage 통합 제공                        |\n| 상태관리          | React Context + SWR              | 경량 상태관리·데이터 패칭, SWR의 Stale-While-Revalidate 캐싱               |\n| 스타일링          | Tailwind CSS (v3.x)              | 유틸리티 클래스 기반 빠른 스타일링, 반응형 레이아웃 지원                  |\n| PWA/오프라인      | Workbox + Service Worker         | 오프라인 캐싱 전략, 푸시 알림 지원, manifest.json 관리                    |\n| 푸시알림          | Web Push API (VAPID)             | 브라우저 푸시 표준, Supabase Functions와 연동 가능                         |\n| 배포/호스팅       | Vercel                            | Next.js 최적화 호스팅, CDN 자동 캐싱, CI/CD 내장                           |\n| 모니터링/로깅     | Sentry + Vercel Analytics        | 오류 추적·성능 모니터링, 배포별 통계 수집                                  |\n\n## 3. System Architecture Design\n\n### Top-Level Building Blocks\n- **PWA 프론트엔드 (Next.js)**  \n  • 페이지(SSR·ISR)  \n  • API Route (로그인·기도제목·그룹·리액션)  \n  • 서비스 워커(Workbox)  \n- **Supabase Backend**  \n  • PostgreSQL 데이터베이스 (users, groups, group_members, prayers, reactions)  \n  • Auth (JWT, RLS)  \n  • Realtime & Storage  \n- **Kakao OAuth 연동**  \n  • Next.js API에서 OAuth 콜백 처리  \n  • Supabase Auth 사용자 생성/조회  \n- **배포 및 CDN (Vercel)**  \n  • 글로벌 엣지 네트워크  \n  • 자동 SSL/TLS 관리  \n- **모니터링 & 로깅**  \n  • Sentry 오류 추적  \n  • Vercel Analytics 성능 지표\n\n### Top-Level Component Interaction Diagram\n```mermaid\ngraph TD\n    A[User Device(PWA)] --> B[Next.js Frontend]\n    B --> C[Next.js API Routes]\n    C --> D[Supabase PostgreSQL]\n    C --> E[Supabase Auth]\n    A --> F[Service Worker(Workbox)]\n    B --> G[Kakao OAuth]\n    D --> H[Realtime Subscription]\n```\n\n- 사용자가 PWA(Next.js) UI에서 API 호출  \n- Next.js API가 Supabase Auth 및 PostgreSQL과 통신  \n- Kakao OAuth 콜백을 Next.js API에서 처리 후 JWT 발급  \n- Service Worker가 오프라인 캐싱 및 푸시 수신 담당  \n- Supabase Realtime을 통해 리액션 카운트 실시간 업데이트  \n\n### Code Organization & Convention\n\n**Domain-Driven Organization Strategy**  \n- Domain Separation: user, auth, group, prayer, reaction  \n- Layer-Based Architecture: presentation (pages/components), business logic (services), data access (lib/supabase), infrastructure (API routes)  \n- Feature-Based Modules: 각 도메인별 독립 폴더  \n- Shared Components: 공통 UI, 유틸리티, 타입 정의  \n\n**Universal File & Folder Structure**\n```\n/\n├── pages\n│   ├── api\n│   │   ├── auth\n│   │   ├── groups\n│   │   ├── prayers\n│   │   └── reactions\n│   ├── _app.tsx\n│   ├── index.tsx\n│   └── [...]\n├── components\n│   ├── Auth\n│   ├── Group\n│   ├── Prayer\n│   └── Reaction\n├── services\n│   ├── authService.ts\n│   ├── groupService.ts\n│   ├── prayerService.ts\n│   └── reactionService.ts\n├── lib\n│   ├── supabaseClient.ts\n│   └── kakaoClient.ts\n├── hooks\n│   ├── useAuth.ts\n│   └── useSWRFetch.ts\n├── public\n│   ├── manifest.json\n│   └── icons/\n├── styles\n│   └── globals.css\n├── sw.js\n├── next.config.js\n├── tsconfig.json\n└── vercel.json\n```\n\n### Data Flow & Communication Patterns\n- **Client-Server 통신**: fetch/SWR 기반 RESTful API 호출, 오류 처리 및 재시도 로직  \n- **Database Interaction**: supabase-js 클라이언트 사용, RLS 정책 적용, 트랜잭션 관리  \n- **External Service Integration**: Kakao SDK → Next.js API → Supabase Auth  \n- **Real-time Communication**: Supabase Realtime 채널로 리액션 카운트 자동 업데이트  \n- **Data Synchronization**: SWR의 stale-while-revalidate, Service Worker 큐잉으로 오프라인 동기화\n\n## 4. Performance & Optimization Strategy\n- ISR(Incremental Static Regeneration)·SSR 병행 사용으로 페이지 로딩 최적화  \n- next/image 활용한 이미지 자동 최적화 및 lazy loading  \n- Tailwind CSS JIT 모드로 CSS 번들 최소화  \n- Vercel CDN 캐싱 헤더 설정, Edge 네트워크 활용  \n- SWR 재검증·데이터 프리페치로 UX 부드러움 확보\n\n## 5. Implementation Roadmap & Milestones\n\n### Phase 1: Foundation (MVP Implementation)\n- **Core Infrastructure**: Next.js 프로젝트 설정, Supabase 프로젝트 및 RLS 적용, Vercel 배포 파이프라인  \n- **Essential Features**: 기도제목 CRUD, 그룹 생성·초대·권한, 리액션, Kakao 로그인, 반응형 UI  \n- **Basic Security**: TLS 설정, Supabase RLS 및 JWT 검증  \n- **Development Setup**: ESLint·Prettier, Git Flow, Vercel Preview 배포  \n- **Timeline**: W1~W6\n\n### Phase 2: Feature Enhancement\n- **Advanced Features**: PWA 오프라인 캐싱, 웹푸시, 검색·필터, 다크모드·접근성(ARIA)  \n- **Performance Optimization**: Lighthouse PWA 90+ 달성, 번들 분석 및 최적화  \n- **Enhanced Security**: CSP 헤더, 보안 감사 스크립트 추가  \n- **Monitoring Implementation**: Sentry 통합, Vercel Analytics 대시보드 구성  \n- **Timeline**: W7~W8\n\n### Phase 3: Scaling & Optimization\n- **Scalability Implementation**: Postgres 파티셔닝, Read Replica, Edge Functions 활용  \n- **Advanced Integrations**: Google·Apple 로그인 옵션, Supabase Functions 확장  \n- **Enterprise Features**: 관리자 대시보드 고도화, 감사 로그, 보고서 생성  \n- **Compliance & Auditing**: GDPR, SOC2 등 규제 준수 기능  \n- **Timeline**: W9~W14\n\n## 6. Risk Assessment & Mitigation Strategies\n\n### Technical Risk Analysis\n- **Technology Risks**: Next.js SSR 응답 지연 → ISR 적용, CDN 캐싱 강화  \n- **Performance Risks**: 대량 데이터 처리 시 DB 병목 → 파티셔닝·인덱스 최적화  \n- **Security Risks**: OAuth 토큰 유출 → RLS·JWT 만료 정책 엄격 적용  \n- **Integration Risks**: Kakao API 변경 → 폴백으로 Google·Apple 준비  \n- **Mitigation Strategies**: 로드테스트, 자동화된 보안 스캔, 장애 복구 문서화\n\n### Project Delivery Risks\n- **Timeline Risks**: 연계 기능 지연 → 우선순위 조정, 병렬 개발  \n- **Resource Risks**: Supabase 경험 부족 → 사전 PoC, 기술 워크숍  \n- **Quality Risks**: 테스트 커버리지 부족 → CI 테스트 파이프라인 강화  \n- **Deployment Risks**: 환경 변수 누락 → GitHub Secrets·Vercel 환경 변수 관리  \n- **Contingency Plans**: 롤백 절차 문서화, 블루-그린 배포 전략 준비",
      "writedAt": "2025-07-19T02:51:46.333Z"
    },
    {
      "type": "guideline",
      "content": "# Code Guidelines for Praygram\n\n## 1. Project Overview  \nPraygram is a Next.js-based PWA using SSR/ISR, TypeScript, Supabase (Postgres/Auth/Storage), Workbox service workers, and Vercel hosting. Key architectural decisions:  \n- **SSR & ISR** via Next.js for fast first-load and on-demand regeneration  \n- **Feature-based domain modules**: user, auth, group, prayer, reaction  \n- **RESTful API Routes** under `/pages/api/*`  \n- **Client state** with React Context & SWR (stale-while-revalidate)  \n- **Offline support** via Workbox + custom `sw.js`  \n- **Auth & Security** by Supabase JWT + RLS  \n\n---\n\n## 2. Core Principles  \n1. **Single Responsibility (SRP)**: Each file/function ≤200 LOC, one purpose only.  \n2. **Strong Typing**: All public APIs, React props, and services use explicit TypeScript types/interfaces.  \n3. **Secure by Default**: Validate JWT on every API route, enforce Supabase RLS policies.  \n4. **Consistent Data Fetching**: All remote data uses SWR with centralized error/retry logic.  \n5. **Performance-First**: Optimize images (`next/image`), use ISR, minimal bundle via Tailwind JIT.  \n\n---\n\n## 3. Language-Specific Guidelines\n\n### 3.1 TypeScript & Next.js  \n- **File Organization**:  \n  - pages/  \n    - api/{auth,groups,prayers,reactions}/*.ts  \n    - _app.tsx, index.tsx, [feature]/*.tsx  \n  - components/{Auth,Group,Prayer,Reaction}/*.tsx  \n  - services/*.ts, lib/*.ts, hooks/*.ts, styles/*.css, sw.js  \n- **Imports**:  \n  - Use absolute imports via `tsconfig.json` paths (`@/components/...`).  \n  - Group imports: external libs → aliases → relative → styles.  \n- **Error Handling**:  \n  - Wrap async logic in `try/catch`, throw `ApiError` with HTTP status/code.  \n  - In SWR hooks, use `errorRetryCount` and custom `onError`.  \n\n### 3.2 Supabase & API Routes  \n- Initialize single `supabaseClient` in `lib/supabaseClient.ts`.  \n- Validate session token on every API route:  \n  ```ts\n  const token = req.headers.authorization?.split(\" \")[1];\n  const { user, error } = await supabase.auth.api.getUser(token);\n  if (error) throw new ApiError(401, \"Unauthorized\");\n  ```  \n- Enforce RLS filters in database; never bypass with `supabase.rpc()`.  \n\n### 3.3 Workbox & Service Worker  \n- Register `sw.js` in `_app.tsx` when `navigator.serviceWorker` available.  \n- Cache strategies:  \n  - `networkFirst` for `/api/*`  \n  - `staleWhileRevalidate` for images and static assets  \n\n---\n\n## 4. Code Style Rules\n\n### 4.1 MUST Follow  \n1. **Named Exports Only**  \n   - Rationale: Easier refactoring and tree-shaking.  \n   ```ts\n   // MUST\n   export function fetchPrayers(): Promise<Prayer[]> { ... }\n   ```  \n2. **Explicit Return Types**  \n   - Rationale: Prevent inference drift.  \n   ```ts\n   // MUST\n   export async function getServerSideProps(): Promise<GetServerSidePropsResult<Props>> {\n     return { props: {} };\n   }\n   ```  \n3. **Descriptive Type Aliases/Interfaces**  \n   - Rationale: Centralized contracts for DTOs.  \n   ```ts\n   // MUST\n   export interface Prayer { id: string; title: string; content: string; createdAt: string; }\n   ```  \n4. **SWR Hooks for Fetching**  \n   - Rationale: Stale-while-revalidate, auto cache.  \n   ```ts\n   // MUST\n   import useSWR from 'swr';\n   export function usePrayers() {\n     return useSWR<Prayer[]>('/api/prayers', fetcher, { revalidateOnFocus: false });\n   }\n   ```  \n5. **Tailwind Utility Classes**  \n   - Rationale: Consistent, minimal CSS.  \n   ```tsx\n   // MUST\n   <button className=\"px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700\">\n     Pray\n   </button>\n   ```  \n\n### 4.2 MUST NOT Do  \n1. **Avoid `any` or Non-strict Types**  \n   - Anti-pattern: defeats TS safety.  \n   ```ts\n   // MUST NOT\n   export function fetchAnyData(): any { /* ... */ }\n   ```  \n2. **No Inline Styles**  \n   - Anti-pattern: breaks Tailwind consistency.  \n   ```tsx\n   // MUST NOT\n   <div style={{ margin: '10px', color: 'red' }}>Bad</div>\n   ```  \n3. **No Large Multi-Responsibility Files**  \n   - Anti-pattern: hard to maintain.  \n   ```ts\n   // MUST NOT\n   // 800 LOC with services, models, handlers in one file\n   ```  \n4. **No Blocking UI during Fetch**  \n   - Anti-pattern: avoid `window.alert` or sync loops.  \n5. **No Direct DOM Manipulation**  \n   - Anti-pattern: conflicts with React.  \n\n---\n\n## 5. Architecture Patterns\n\n### 5.1 Component & Module Structure  \n- **Feature Folder**: Each domain has its folder with components, services, types, hooks.  \n- **Shared**: `/components/ui`, `/lib`, `/hooks`.  \n- **Pages** use `getServerSideProps` or `getStaticProps` per route need.\n\n### 5.2 Data Flow  \n- **Fetch**: SWR `useXYZ` → RESTful `/api/xyz` → Supabase.  \n- **Cache**: SWR + service worker.  \n- **Sync**: Service worker background sync for offline writes.\n\n### 5.3 State Management  \n- **Auth State**: `AuthContext` with `useAuth()` hook, stores JWT + user.  \n- **Global UI State**: small, use React Context for theme/dark mode.  \n- **No Redux**: prefer built-in Context + SWR.\n\n### 5.4 API Design  \n- **RESTful Endpoints**:  \n  - `GET /api/prayers` → list  \n  - `POST /api/prayers` → create  \n  - `PUT /api/prayers/[id]` → update  \n  - `DELETE /api/prayers/[id]` → delete  \n- **HTTP Status Codes**: 200, 201, 400, 401, 404, 500.  \n- **Error Payload**: `{ error: { code: string; message: string; } }`\n\n---\n\n## 6. Example Code Snippets\n\n### 6.1 Valid API Route  \n```ts\n// pages/api/prayers/index.ts\nimport { NextApiRequest, NextApiResponse } from 'next';\nimport { supabase } from '@/lib/supabaseClient';\nimport { Prayer } from '@/services/prayerService';\nimport { ApiError } from '@/lib/errors';\n\nexport default async function handler(req: NextApiRequest, res: NextApiResponse) {\n  try {\n    const token = req.headers.authorization?.split(' ')[1] ?? '';\n    const { user, error: authErr } = await supabase.auth.api.getUser(token);\n    if (authErr || !user) throw new ApiError(401, 'Unauthorized');\n\n    if (req.method === 'GET') {\n      const { data, error } = await supabase\n        .from<Prayer>('prayers')\n        .select('*')\n        .order('createdAt', { ascending: false });\n      if (error) throw new ApiError(500, error.message);\n      return res.status(200).json(data);\n    }\n    throw new ApiError(405, 'Method Not Allowed');\n  } catch (err) {\n    const { status = 500, message } = ApiError.parse(err);\n    return res.status(status).json({ error: { code: String(status), message } });\n  }\n}\n```\n\n### 6.2 Forbidden Pattern  \n```ts\n// pages/api/prayers.ts\n// MUST NOT: Single file for all methods, untyped, no auth check\nexport default async function handler(req, res) {\n  const all = await supabase.from('prayers').select('*'); // no error handling\n  res.json(all);\n}\n```\n\n### 6.3 SWR Hook  \n```ts\n// hooks/usePrayers.ts\nimport useSWR from 'swr';\nimport { Prayer } from '@/services/prayerService';\n\nconst fetcher = (url: string) =>\n  fetch(url).then(r => r.json());\n\nexport function usePrayers() {\n  return useSWR<Prayer[]>('/api/prayers', fetcher, {\n    errorRetryCount: 3,\n    revalidateOnFocus: true,\n  });\n}\n```\n\n### 6.4 React Component  \n```tsx\n// components/Prayer/List.tsx\nimport React from 'react';\nimport { usePrayers } from '@/hooks/usePrayers';\n\nexport function PrayerList() {\n  const { data, error } = usePrayers();\n  if (error) return <p className=\"text-red-500\">Failed to load.</p>;\n  if (!data) return <p>Loading...</p>;\n  return (\n    <ul className=\"space-y-2\">\n      {data.map(p => (\n        <li key={p.id} className=\"p-4 bg-white rounded shadow\">\n          <h3 className=\"text-lg font-semibold\">{p.title}</h3>\n          <p>{p.content}</p>\n        </li>\n      ))}\n    </ul>\n  );\n}\n```\n\n### 6.5 Forbidden React Pattern  \n```tsx\n// components/PrayerListBad.tsx\n// MUST NOT: no loading/error handling, inline style\nexport function PrayerListBad() {\n  const data = fetch('/api/prayers').then(res => res.json());\n  return <div style={{ color: 'red' }}>{data.map(p => <div>{p.title}</div>)}</div>;\n}\n```\n\n---\n\n_End of Code Guidelines_",
      "writedAt": "2025-07-19T02:51:46.333Z"
    },
    {
      "type": "step-by-step",
      "content": "\n## Core Directive\nYou are a senior software engineer AI assistant. For EVERY task request, you MUST follow the three-phase process below in exact order. Each phase must be completed with expert-level precision and detail.\n\n## Guiding Principles\n- **Minimalistic Approach**: Implement high-quality, clean solutions while avoiding unnecessary complexity\n- **Expert-Level Standards**: Every output must meet professional software engineering standards\n- **Concrete Results**: Provide specific, actionable details at each step\n\n---\n\n## Phase 1: Codebase Exploration & Analysis\n**REQUIRED ACTIONS:**\n1. **Systematic File Discovery**\n   - List ALL potentially relevant files, directories, and modules\n   - Search for related keywords, functions, classes, and patterns\n   - Examine each identified file thoroughly\n\n2. **Convention & Style Analysis**\n   - Document coding conventions (naming, formatting, architecture patterns)\n   - Identify existing code style guidelines\n   - Note framework/library usage patterns\n   - Catalog error handling approaches\n\n**OUTPUT FORMAT:**\n```\n### Codebase Analysis Results\n**Relevant Files Found:**\n- [file_path]: [brief description of relevance]\n\n**Code Conventions Identified:**\n- Naming: [convention details]\n- Architecture: [pattern details]\n- Styling: [format details]\n\n**Key Dependencies & Patterns:**\n- [library/framework]: [usage pattern]\n```\n\n---\n\n## Phase 2: Implementation Planning\n**REQUIRED ACTIONS:**\nBased on Phase 1 findings, create a detailed implementation roadmap.\n\n**OUTPUT FORMAT:**\n```markdown\n## Implementation Plan\n\n### Module: [Module Name]\n**Summary:** [1-2 sentence description of what needs to be implemented]\n\n**Tasks:**\n- [ ] [Specific implementation task]\n- [ ] [Specific implementation task]\n\n**Acceptance Criteria:**\n- [ ] [Measurable success criterion]\n- [ ] [Measurable success criterion]\n- [ ] [Performance/quality requirement]\n\n### Module: [Next Module Name]\n[Repeat structure above]\n```\n\n---\n\n## Phase 3: Implementation Execution\n**REQUIRED ACTIONS:**\n1. Implement each module following the plan from Phase 2\n2. Verify ALL acceptance criteria are met before proceeding\n3. Ensure code adheres to conventions identified in Phase 1\n\n**QUALITY GATES:**\n- [ ] All acceptance criteria validated\n- [ ] Code follows established conventions\n- [ ] Minimalistic approach maintained\n- [ ] Expert-level implementation standards met\n\n---\n\n## Success Validation\nBefore completing any task, confirm:\n- ✅ All three phases completed sequentially\n- ✅ Each phase output meets specified format requirements\n- ✅ Implementation satisfies all acceptance criteria\n- ✅ Code quality meets professional standards\n\n## Response Structure\nAlways structure your response as:\n1. **Phase 1 Results**: [Codebase analysis findings]\n2. **Phase 2 Plan**: [Implementation roadmap]  \n3. **Phase 3 Implementation**: [Actual code with validation]\n",
      "writedAt": "2025-07-19T02:51:46.333Z"
    },
    {
      "type": "tdd",
      "content": "\n# TDD Process Guidelines - Cursor Rules\n\n## ⚠️ MANDATORY: Follow these rules for EVERY implementation and modification\n\n**This document defines the REQUIRED process for all code changes. No exceptions without explicit team approval.**\n\n## Core Cycle: Red → Green → Refactor\n\n### 1. RED Phase\n- Write a failing test FIRST\n- Test the simplest scenario\n- Verify test fails for the right reason\n- One test at a time\n\n### 2. GREEN Phase  \n- Write MINIMAL code to pass\n- \"Fake it till you make it\" is OK\n\n- YAGNI principle\n\n### 3. REFACTOR Phase\n- Remove duplication\n- Improve naming\n- Simplify structure\n- Keep tests passing\n\n## Test Quality: FIRST Principles\n- **Fast**: Milliseconds, not seconds\n- **Independent**: No shared state\n- **Repeatable**: Same result every time\n- **Self-validating**: Pass/fail, no manual checks\n- **Timely**: Written just before code\n\n## Test Structure: AAA Pattern\n```\n// Arrange\nSet up test data and dependencies\n\n// Act\nExecute the function/method\n\n// Assert\nVerify expected outcome\n```\n\n## Implementation Flow\n1. **List scenarios** before coding\n2. **Pick one scenario** → Write test\n3. **Run test** → See it fail (Red)\n4. **Implement** → Make it pass (Green)\n5. **Refactor** → Clean up (Still Green)\n6. **Commit** → Small, frequent commits\n7. **Repeat** → Next scenario\n\n## Test Pyramid Strategy\n- **Unit Tests** (70%): Fast, isolated, numerous\n- **Integration Tests** (20%): Module boundaries\n- **Acceptance Tests** (10%): User scenarios\n\n## Outside-In vs Inside-Out\n- **Outside-In**: Start with user-facing test → Mock internals → Implement details\n- **Inside-Out**: Start with core logic → Build outward → Integrate components\n\n## Common Anti-patterns to Avoid\n- Testing implementation details\n- Fragile tests tied to internals  \n- Missing assertions\n- Slow, environment-dependent tests\n- Ignored failing tests\n\n## When Tests Fail\n1. **Identify**: Regression, flaky test, or spec change?\n2. **Isolate**: Narrow down the cause\n3. **Fix**: Code bug or test bug\n4. **Learn**: Add missing test cases\n\n## Team Practices\n- CI/CD integration mandatory\n- No merge without tests\n- Test code = Production code quality\n- Pair programming for complex tests\n- Regular test refactoring\n\n## Pragmatic Exceptions\n- UI/Graphics: Manual + snapshot tests\n- Performance: Benchmark suites\n- Exploratory: Spike then test\n- Legacy: Test on change\n\n## Remember\n- Tests are living documentation\n- Test behavior, not implementation\n- Small steps, fast feedback\n- When in doubt, write a test\n",
      "writedAt": "2025-07-19T02:51:46.333Z"
    },
    {
      "type": "clean-code",
      "content": "\n# Clean Code Guidelines\n\nYou are an expert software engineer focused on writing clean, maintainable code. Follow these principles rigorously:\n\n## Core Principles\n- **DRY** - Eliminate duplication ruthlessly\n- **KISS** - Simplest solution that works\n- **YAGNI** - Build only what's needed now\n- **SOLID** - Apply all five principles consistently\n- **Boy Scout Rule** - Leave code cleaner than found\n\n## Naming Conventions\n- Use **intention-revealing** names\n- Avoid abbreviations except well-known ones (e.g., URL, API)\n- Classes: **nouns**, Methods: **verbs**, Booleans: **is/has/can** prefix\n- Constants: UPPER_SNAKE_CASE\n- No magic numbers - use named constants\n\n## Functions & Methods\n- **Single Responsibility** - one reason to change\n- Maximum 20 lines (prefer under 10)\n- Maximum 3 parameters (use objects for more)\n- No side effects in pure functions\n- Early returns over nested conditions\n\n## Code Structure\n- **Cyclomatic complexity** < 10\n- Maximum nesting depth: 3 levels\n- Organize by feature, not by type\n- Dependencies point inward (Clean Architecture)\n- Interfaces over implementations\n\n## Comments & Documentation\n- Code should be self-documenting\n- Comments explain **why**, not what\n- Update comments with code changes\n- Delete commented-out code immediately\n- Document public APIs thoroughly\n\n## Error Handling\n- Fail fast with clear messages\n- Use exceptions over error codes\n- Handle errors at appropriate levels\n- Never catch generic exceptions\n- Log errors with context\n\n## Testing\n- **TDD** when possible\n- Test behavior, not implementation\n- One assertion per test\n- Descriptive test names: `should_X_when_Y`\n- **AAA pattern**: Arrange, Act, Assert\n- Maintain test coverage > 80%\n\n## Performance & Optimization\n- Profile before optimizing\n- Optimize algorithms before micro-optimizations\n- Cache expensive operations\n- Lazy load when appropriate\n- Avoid premature optimization\n\n## Security\n- Never trust user input\n- Sanitize all inputs\n- Use parameterized queries\n- Follow **principle of least privilege**\n- Keep dependencies updated\n- No secrets in code\n\n## Version Control\n- Atomic commits - one logical change\n- Imperative mood commit messages\n- Reference issue numbers\n- Branch names: `type/description`\n- Rebase feature branches before merging\n\n## Code Reviews\n- Review for correctness first\n- Check edge cases\n- Verify naming clarity\n- Ensure consistent style\n- Suggest improvements constructively\n\n## Refactoring Triggers\n- Duplicate code (Rule of Three)\n- Long methods/classes\n- Feature envy\n- Data clumps\n- Divergent change\n- Shotgun surgery\n\n## Final Checklist\nBefore committing, ensure:\n- [ ] All tests pass\n- [ ] No linting errors\n- [ ] No console logs\n- [ ] No commented code\n- [ ] No TODOs without tickets\n- [ ] Performance acceptable\n- [ ] Security considered\n- [ ] Documentation updated\n\nRemember: **Clean code reads like well-written prose**. Optimize for readability and maintainability over cleverness.\n",
      "writedAt": "2025-07-19T02:51:46.333Z"
    },
    {
      "type": "git-commit-message",
      "content": "\n# Git Commit Message Rules\n\n## Format Structure\n```\n<type>(<scope>): <description>\n\n[optional body]\n\n[optional footer]\n```\n\n## Types (Required)\n- `feat`\n- `fix`\n- `docs`\n- `style`\n- `refactor`\n- `perf`\n- `test`\n- `chore`\n- `ci`\n- `build`\n- `revert`\n\n## Scope (Optional)\n- Component, file, or feature area affected\n- Use kebab-case: `user-auth`, `payment-api`\n- Omit if change affects multiple areas\n\n## Description Rules\n- Use imperative mood\n- No capitalization of first letter\n- No period at end\n- Max 50 characters\n- Be specific and actionable\n\n## Body Guidelines\n- Wrap at 72 characters\n- Explain what and why, not how\n- Separate from description with blank line\n- Use bullet points for multiple changes\n\n## Footer Format\n- `BREAKING CHANGE:` for breaking changes\n- `Closes #123` for issue references\n- `Co-authored-by: Vooster AI (@vooster-ai)`\n\n## Examples\n```\nfeat(auth): add OAuth2 Google login\n\nfix: resolve memory leak in user session cleanup\n\ndocs(api): update authentication endpoints\n\nrefactor(utils): extract validation helpers to separate module\n\nBREAKING CHANGE: remove deprecated getUserData() method\n```\n\n## Workflow Integration\n**ALWAYS write a commit message after completing any development task, feature, or bug fix.**\n\n## Validation Checklist\n- [ ] Type is from approved list\n- [ ] Description under 50 chars\n- [ ] Imperative mood used\n- [ ] No trailing period\n- [ ] Meaningful and clear context\n    ",
      "writedAt": "2025-07-19T02:51:46.333Z"
    }
  ]
}